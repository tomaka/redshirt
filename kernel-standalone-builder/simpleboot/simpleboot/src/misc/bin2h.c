/*
 * src/misc/bin2h.c
 * https://gitlab.com/bztsrc/simpleboot
 *
 * Copyright (C) 2023 bzt (bztsrc@gitlab), MIT license
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL ANY
 * DEVELOPER OR DISTRIBUTOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * @brief Simple helper utility for embedding binary data into C source ("ld -b" isn't portable)
 */

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../loader.h"  /* elf headers */

int main(int argc, char **argv)
{
    FILE *f, *h, *b;
    int size, i, j, k;
    unsigned char *buff = NULL;
    char name[256];

    if(argc < 2){ printf("bin2h <bin file> [bin file2...]\r\n"); return 1; }
    h = fopen("data.h", "w"); if(!h) { fprintf(stderr, "bin2h: unable to open data.h\r\n"); return 1; }
    fprintf(h, "/*\n"
        " * src/data.h\n"
        " * https://codeberg.org/bzt/simpleboot\n"
        " *\n"
        " * Copyright (C) 2023 bzt, MIT license\n"
        " *\n"
        " * Permission is hereby granted, free of charge, to any person obtaining a copy\n"
        " * of this software and associated documentation files (the \"Software\"), to\n"
        " * deal in the Software without restriction, including without limitation the\n"
        " * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n"
        " * sell copies of the Software, and to permit persons to whom the Software is\n"
        " * furnished to do so, subject to the following conditions:\n"
        " *\n"
        " * The above copyright notice and this permission notice shall be included in\n"
        " * all copies or substantial portions of the Software.\n"
        " *\n"
        " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
        " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
        " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL ANY\n"
        " * DEVELOPER OR DISTRIBUTOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n"
        " * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n"
        " * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        " *\n"
        " * @brief Embedded loader binary data, used by the image creator\n"
        " */\n\n/* generated by bin2h, do not edit */\n\n");
    for(i = 1; i < argc; i++){
        f = fopen(argv[i],"rb");
        if(f) {
            fseek(f, 0, SEEK_END);
            size = (int)ftell(f);
            fseek(f, 0, SEEK_SET);
            buff = (unsigned char*)malloc(size + 512);
            if(!buff) { fprintf(stderr, "bin2h: memory allocation error\r\n"); return 2; }
            fread(buff, 1, size, f);
            fclose(f);
            for(j = 0; argv[i][j]; j++) { name[j] = argv[i][j] == '.' || argv[i][j] <= ' ' ? '_' : argv[i][j]; } name[j] = 0;
            /* ehhh LLVM lld accepts -stub flag, but then does nothing with it, lld/COFF/Writer.cpp always writes dosProgram */
            if(!strcmp(name, "loader_x86_efi")) {
                memset(buff + size, 0, 512);
                size = (size + 511) & ~511;
                memset(buff + 0x40, 0, 0x38); memcpy(buff + 0x40, "Simpleboot https://codeberg.org/bzt/simpleboot\0x86_64", 53);
                b = fopen("loader_x86.efi", "wb"); if(b) { fwrite(buff, 1, size, b); fclose(b); }
            }
            /* objcopy can't interpret program headers from another platform's elf... */
            if(!strcmp(name, "loader_rpi_o")) {
                k = (int)((Elf64_Phdr*)(buff + ((Elf64_Ehdr*)buff)->e_phoff))->p_offset;
                size = (int)((Elf64_Phdr*)(buff + ((Elf64_Ehdr*)buff)->e_phoff))->p_filesz;
                /* patch _bss_start and _bss_end values, must be right after the default names */
                for(j = 0; j < size - 128; j += 16)
                    if(!memcmp(buff + j + k, "kernel\0\0\0\0\0\0\0\0\0", 16)) {
                        *((uint32_t*)(buff + j + k + 128)) =
                            (uint32_t)((Elf64_Phdr*)(buff + ((Elf64_Ehdr*)buff)->e_phoff))->p_vaddr +
                            (uint32_t)((Elf64_Phdr*)(buff + ((Elf64_Ehdr*)buff)->e_phoff))->p_filesz;
                        *((uint32_t*)(buff + j + k + 128 + 4)) =
                            ((uint32_t)((Elf64_Phdr*)(buff + ((Elf64_Ehdr*)buff)->e_phoff))->p_vaddr +
                            (uint32_t)((Elf64_Phdr*)(buff + ((Elf64_Ehdr*)buff)->e_phoff))->p_memsz + 4095) & ~4095;
                        break;
                    }
                /* make sure we write out multiple of 512 bytes */
                memset(buff + k + size, 0, 512);
                size = (size + 511) & ~511;
                /* it would be enough just to include in data.h, but also write out as bin file for debugging */
                strcpy(name, "loader_rpi_bin");
                b = fopen("loader_rpi.bin", "wb");
                if(!b) { fclose(h); free(buff); fprintf(stderr, "bin2h: unable to open loader_rpi.bin\r\n"); return 1; }
                fwrite(buff + k, 1, size, b);
                fclose(b);
            } else k = 0;
            fprintf(h, "unsigned char %s[%u] = { ", name, size);
            for(j = 0; j < size; j++) fprintf(h, "%s%d", j?",":"", buff[j + k]);
            fprintf(h, " };\n");
            free(buff);
        }
    }
    fclose(h);
    return 0;
}
