// Copyright (C) 2019  Pierre Krieger
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

//! Manages a registered networking interface.

use hashbrown::HashMap;
use smoltcp::{phy, time::Instant};
use std::{
    collections::BTreeMap,
    fmt,
    mem,
    net::{IpAddr, SocketAddr},
    sync::{Arc, Mutex, MutexGuard},
};

/// State machine encompassing an Ethernet interface and the sockets operating on it.
pub struct NetInterfaceState {
    /// State of the Ethernet interface.
    ethernet: smoltcp::iface::EthernetInterface<'static, 'static, 'static, RawDevice>,

    /// Buffer of data to send out to the virtual Ethernet cable.
    /// Shared with the device within [`NetInterfaceState::ethernet`].
    /// Note: this is a hack around the fact that the API of `smoltcp` wasn't really designed
    /// around being able to retreive the data of the interface.
    device_out_buffer: Arc<Mutex<Vec<u8>>>,

    /// Buffer of data received from the virtual Ethernet cable.
    /// Shared with the device within [`NetInterfaceState::ethernet`].
    /// Note: this is a hack around the fact that the API of `smoltcp` wasn't really designed
    /// around being able to retreive the data of the interface.
    device_in_buffer: Arc<Mutex<Vec<u8>>>,

    /// Collection of all the active sockets that currently operate on this interface.
    sockets: smoltcp::socket::SocketSet<'static, 'static, 'static>,

    /// State of the sockets. Maintained in parallel with [`NetInterfaceState`].
    sockets_state: HashMap<SocketId, SocketState>,

    /// Future that triggers the next time we should poll [`NetInterfaceState::ethernet`].
    /// Must be set to `None` whenever we modify [`NetInterfaceState::ethernet`] in such a way that
    /// it could produce an event.
    next_event_delay: Option<redshirt_time_interface::Delay>,
}

/// Prototype for a [`NetInterfaceState`] under construction.
pub struct NetInterfaceStateBuilder {
    /// List of IP addresses that this interface will handle.
    ip_addresses: Vec<smoltcp::wire::IpCidr>,
    /// MAC address of the device.
    mac_address: [u8; 6],
}

/// Event generated by the [`NetInterfaceState::next_event`] function.
#[derive(Debug)]
pub enum NetInterfaceEvent<'a> {
    /// Data to be sent out by the Ethernet cable.
    EthernetCableOut(Vec<u8>),
    /// A TCP/IP socket has connected to its target.
    TcpConnected(TcpSocket<'a>),
    /// A TCP/IP socket has been closed by the remote.
    TcpClosed(TcpSocket<'a>),
    /// A TCP/IP socket has data ready to be read.
    TcpReadReady(TcpSocket<'a>),
    /// A TCP/IP socket has finished writing the data that we passed to it, and is now ready to
    /// accept more.
    TcpWriteFinished(TcpSocket<'a>),
}

/// Internal enum similar to [`NetInterfaceEvent`], except that it is `'static`.
///
/// Necessary because of borrow checker issue.
#[derive(Debug)]
enum NetInterfaceEventStatic {
    EthernetCableOut(Vec<u8>),
    TcpConnected(SocketId),
    TcpClosed(SocketId),
    TcpReadReady(SocketId),
    TcpWriteFinished(SocketId),
}

/// Active TCP socket within a [`NetInterfaceState`].
pub struct TcpSocket<'a> {
    /// Reference to the interface.
    interface: &'a mut NetInterfaceState,
    /// Identifier of that socket within [`NetInterfaceState::sockets`].
    id: SocketId,
}

/// State of a socket that we maintain in parallel to its actual state.
struct SocketState {
    is_connected: bool,
    is_closed: bool,
    read_ready: bool,
    write_ready: bool,
    write_remaining: Vec<u8>,
}

#[derive(Debug, thiserror::Error)]
pub enum ConnectError {
    #[error("No route available for this destination")]
    NoRoute,
}

/// Opaque identifier of a socket within a [`NetInterfaceState`].
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SocketId(smoltcp::socket::SocketHandle);

impl NetInterfaceState {
    /// Initializes a new TCP connection which tries to connect to the given
    /// [`SocketAddr`](std::net::SocketAddr).
    pub fn build_tcp_socket(&mut self, listen: bool, addr: &SocketAddr) -> Result<TcpSocket, ConnectError> {
        let mut socket = {
            let rx_buf = smoltcp::socket::TcpSocketBuffer::new(vec![0; 1024]);
            let tx_buf = smoltcp::socket::TcpSocketBuffer::new(vec![0; 1024]);
            smoltcp::socket::TcpSocket::new(rx_buf, tx_buf)
        };

        if listen {
            socket.listen(addr.clone()).unwrap();
        } else {
            socket.connect(addr.clone(), addr.clone()).unwrap(); // TODO: bad source
        }

        let id = SocketId(self.sockets.add(socket));
        self.sockets_state.insert(id, SocketState {
            is_connected: false,
            is_closed: false,
            read_ready: false,
            write_ready: true,
            write_remaining: Vec::new(),
        });
        self.next_event_delay = None;

        Ok(TcpSocket { interface: self, id })
    }

    /// Returns an existing TCP socket by its ID.
    pub fn tcp_socket_by_id(&mut self, id: SocketId) -> Option<TcpSocket> {
        if !self.sockets_state.contains_key(&id) {
            return None;
        }

        Some(TcpSocket {
            interface: self,
            id,
        })
    }

    /// Injects some data coming from the Ethernet cable.
    ///
    /// Call [`NetInterfaceState::next_event`] in order to obtain the result.
    pub fn inject_interface_data(&mut self, data: impl AsRef<[u8]>) {
        let mut device_in_buffer = self.device_in_buffer.try_lock().unwrap();
        device_in_buffer.extend_from_slice(data.as_ref());
        self.next_event_delay = None;
    }

    pub async fn next_event<'a>(&'a mut self) -> NetInterfaceEvent<'a> {
        match self.next_event_static().await {
            NetInterfaceEventStatic::EthernetCableOut(buf) => {
                NetInterfaceEvent::EthernetCableOut(buf)
            },
            NetInterfaceEventStatic::TcpConnected(id) => {
                NetInterfaceEvent::TcpConnected(self.tcp_socket_by_id(id).unwrap())
            },
            NetInterfaceEventStatic::TcpClosed(id) => {
                NetInterfaceEvent::TcpClosed(self.tcp_socket_by_id(id).unwrap())
            },
            NetInterfaceEventStatic::TcpReadReady(id) => {
                NetInterfaceEvent::TcpReadReady(self.tcp_socket_by_id(id).unwrap())
            },
            NetInterfaceEventStatic::TcpWriteFinished(id) => {
                NetInterfaceEvent::TcpWriteFinished(self.tcp_socket_by_id(id).unwrap())
            },
        }
    }

    pub async fn next_event_static(&mut self) -> NetInterfaceEventStatic {
        loop {
            // First, check the out buffer.
            {
                let mut device_out_buffer = self.device_out_buffer.try_lock().unwrap();
                if !device_out_buffer.is_empty() {
                    let out = mem::replace(&mut *device_out_buffer, Vec::new());
                    return NetInterfaceEventStatic::EthernetCableOut(out);
                }
            }

            // Check whether any socket has changed state.
            for (socket_id, socket_state) in &mut self.sockets_state {
                let mut smoltcp_socket = self.sockets.get::<smoltcp::socket::TcpSocket>(socket_id.0);

                // Check if this socket got connected.
                if !socket_state.is_connected && smoltcp_socket.may_send() {
                    socket_state.is_connected = true;
                    return NetInterfaceEventStatic::TcpConnected(*socket_id);
                }

                // Check if this socket got closed.
                if !socket_state.is_closed && !smoltcp_socket.is_open() {
                    socket_state.is_closed = true;
                    // TODO: also remove from list
                    return NetInterfaceEventStatic::TcpClosed(*socket_id);
                }

                // Check if this socket has data for reading.
                if !socket_state.read_ready && smoltcp_socket.can_recv() {
                    socket_state.read_ready = true;
                    return NetInterfaceEventStatic::TcpReadReady(*socket_id);
                }

                // Continue writing `write_remaining`.
                if smoltcp_socket.can_send() && !socket_state.write_remaining.is_empty() {
                    let written = smoltcp_socket.send_slice(&socket_state.write_remaining).unwrap();
                    socket_state.write_remaining = socket_state.write_remaining.split_off(written);
                }

                // Report when this socket is available for writing.
                if smoltcp_socket.may_send() && !socket_state.write_ready && socket_state.write_remaining.is_empty() {
                    socket_state.write_ready = true;
                    return NetInterfaceEventStatic::TcpWriteFinished(*socket_id);
                }
            }

            // Perform an active wait if any is going on.
            {
                if let Some(next_event_delay) = self.next_event_delay.as_mut() {
                    next_event_delay.await;
                }
                self.next_event_delay = None;
            }

            self.ethernet.poll(&mut self.sockets, now().await).unwrap();
            self.next_event_delay = match self.ethernet.poll_delay(&mut self.sockets, now().await) {
                Some(d) => Some(redshirt_time_interface::Delay::new(d.into())),
                None => continue,
            };
        }
    }
}

impl fmt::Debug for NetInterfaceState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("NetInterfaceState").finish()
    }
}

impl Default for NetInterfaceStateBuilder {
    fn default() -> Self {
        NetInterfaceStateBuilder {
            ip_addresses: Vec::new(),
            mac_address: [0x01, 0x00, 0x00, 0x00, 0x00, 0x02],      // TODO: force config?
        }
    }
}

impl NetInterfaceStateBuilder {
    /// Adds an IP address and submask that this interface is known to handle.
    // TODO: expand description
    pub fn with_ip_addr(mut self, ip_addr: IpAddr, prefix_len: u8) -> Self {
        // TODO: check overlap
        match ip_addr {
            IpAddr::V4(addr) => {
                assert!(prefix_len <= 32);
                self.ip_addresses.push(From::from(smoltcp::wire::Ipv4Cidr::new(From::from(addr), prefix_len)));
            }
            IpAddr::V6(addr) => {
                assert!(prefix_len <= 64);
                self.ip_addresses.push(From::from(smoltcp::wire::Ipv6Cidr::new(From::from(addr), prefix_len)));
            }
        }

        self
    }

    /// Sets the MAC address of the device.
    pub fn with_mac_address(mut self, mac: [u8; 6]) -> Self {
        self.mac_address = mac;
        self
    }

    /// Builds the [`NetInterfaceState`].
    pub fn build(mut self) -> NetInterfaceState {
        // TODO: with_capacity?
        let device_out_buffer = Arc::new(Mutex::new(Vec::new()));
        let device_in_buffer = Arc::new(Mutex::new(Vec::new()));

        let device = RawDevice {
            device_out_buffer: device_out_buffer.clone(),
            device_in_buffer: device_in_buffer.clone(),
        };

        self.ip_addresses.shrink_to_fit();

        let interface = smoltcp::iface::EthernetInterfaceBuilder::new(device)
            .ethernet_addr(smoltcp::wire::EthernetAddress(self.mac_address))
            .ip_addrs(self.ip_addresses)
            .routes(smoltcp::iface::Routes::new(BTreeMap::new()))
            .neighbor_cache(smoltcp::iface::NeighborCache::new(BTreeMap::new()))
            .finalize();

        NetInterfaceState {
            ethernet: interface,
            device_out_buffer,
            device_in_buffer,
            sockets: smoltcp::socket::SocketSet::new(Vec::new()),
            sockets_state: HashMap::new(),
            next_event_delay: None,
        }
    }
}

impl fmt::Debug for NetInterfaceStateBuilder {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("NetInterfaceStateBuilder").finish()
    }
}

impl<'a> TcpSocket<'a> {
    /// Returns the unique identifier of this socket.
    pub fn id(&self) -> SocketId {
        self.id
    }

    /// Starts the process of closing the TCP socket.
    pub fn close(&mut self) {
        let mut socket = self.interface.sockets.get::<smoltcp::socket::TcpSocket<'static>>(self.id.0);
        socket.close();
    }

    /// Instantly drops the socket without a proper shutdown.
    pub fn reset(self) {
        let mut socket = self.interface.sockets.get::<smoltcp::socket::TcpSocket<'static>>(self.id.0);
        socket.abort();
        self.interface.sockets_state.get_mut(&self.id).unwrap().is_closed = true;
    }

    /// Reads the data that has been received on the TCP socket.
    ///
    /// Returns an empty `Vec` if there is no data available.
    pub fn read(&mut self) -> Vec<u8> {
        let mut socket = self.interface.sockets.get::<smoltcp::socket::TcpSocket<'static>>(self.id.0);
        if !socket.can_recv() {
            return Vec::new();
        }

        self.interface.sockets_state.get_mut(&self.id).unwrap().read_ready = false;

        let recv_queue_len = socket.recv_queue();
        let mut out = Vec::with_capacity(recv_queue_len);
        unsafe { out.set_len(recv_queue_len); }
        let n_recved = socket.recv_slice(&mut out).unwrap();
        debug_assert_eq!(n_recved, recv_queue_len);
        debug_assert_eq!(socket.recv_queue(), 0);
        out
    }

    /// Passes a buffer that the socket will encode into Ethernet frames.
    ///
    /// Only one buffer can be active at any given point in time. If a buffer is already active,
    /// returns `Err(buffer)`.
    pub fn set_write_buffer(&mut self, buffer: Vec<u8>) -> Result<(), Vec<u8>> {
        let mut state = self.interface.sockets_state.get_mut(&self.id).unwrap();
        if !state.write_remaining.is_empty() {
            return Err(buffer);
        }

        state.write_ready = false;
        state.write_remaining = buffer;
        Ok(())
    }

    /// Internal function that returns the `smoltcp::socket::TcpSocket` contained within the set.
    fn smoltcp_socket(&mut self) -> smoltcp::socket::SocketRef<smoltcp::socket::TcpSocket<'static>> {
        self.interface.sockets.get::<smoltcp::socket::TcpSocket<'static>>(self.id.0)
    }
}

impl<'a> fmt::Debug for TcpSocket<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_tuple("TcpSocket").field(&self.id()).finish()
    }
}

// TODO: remove
async fn now() -> smoltcp::time::Instant {
    let now = redshirt_time_interface::monotonic_clock().await;
    smoltcp::time::Instant::from_millis((now / 1_000_000) as i64) // TODO: don't use as
}

/// Implementation of `smoltcp::phy::Device`.
struct RawDevice {
    /// Buffer of data to send out to the virtual Ethernet cable.
    /// Shared with the [`NetInterfaceState`].
    /// Note: this is a hack around the fact that the API of `smoltcp` wasn't really designed
    /// around being able to retreive the data of the interface.
    device_out_buffer: Arc<Mutex<Vec<u8>>>,

    /// Buffer of data received from the virtual Ethernet cable.
    /// Shared with the [`NetInterfaceState`].
    /// Note: this is a hack around the fact that the API of `smoltcp` wasn't really designed
    /// around being able to retreive the data of the interface.
    device_in_buffer: Arc<Mutex<Vec<u8>>>,
}

impl<'a> smoltcp::phy::Device<'a> for RawDevice {
    type RxToken = RawDeviceRxToken<'a>;
    type TxToken = RawDeviceTxToken<'a>;

    fn receive(&'a mut self) -> Option<(Self::RxToken, Self::TxToken)> {
        let in_buffer = self.device_in_buffer.try_lock().unwrap();
        if in_buffer.is_empty() {
            return None;
        }

        let in_buffer = self.device_in_buffer.try_lock().unwrap();
        if in_buffer.is_empty() {
            return None;
        }

        let out_buffer = self.device_out_buffer.try_lock().unwrap();
        if !out_buffer.is_empty() {
            return None;
        }

        let rx = RawDeviceRxToken {
            buffer: in_buffer,
        };

        let tx = RawDeviceTxToken {
            buffer: out_buffer,
        };

        Some((rx, tx))
    }

    fn transmit(&'a mut self) -> Option<Self::TxToken> {
        let out_buffer = self.device_out_buffer.try_lock().unwrap();
        if !out_buffer.is_empty() {
            return None;
        }

        Some(RawDeviceTxToken {
            buffer: out_buffer,
        })
    }

    fn capabilities(&self) -> phy::DeviceCapabilities {
        let mut caps: phy::DeviceCapabilities = Default::default();
        caps.max_transmission_unit = 9216; // FIXME:
        caps.max_burst_size = None;
        caps.checksum = phy::ChecksumCapabilities::ignored();
        caps
    }
}

struct RawDeviceRxToken<'a> {
    buffer: MutexGuard<'a, Vec<u8>>,
}

impl<'a> phy::RxToken for RawDeviceRxToken<'a> {
    fn consume<R, F>(mut self, timestamp: Instant, f: F) -> Result<R, smoltcp::Error>
    where
        F: FnOnce(&mut [u8]) -> Result<R, smoltcp::Error>,
    {
        let result = f(&mut self.buffer);
        self.buffer.clear();
        result
    }
}

struct RawDeviceTxToken<'a> {
    buffer: MutexGuard<'a, Vec<u8>>,
}

impl<'a> phy::TxToken for RawDeviceTxToken<'a> {
    fn consume<R, F>(mut self, timestamp: Instant, len: usize, f: F) -> Result<R, smoltcp::Error>
    where
        F: FnOnce(&mut [u8]) -> Result<R, smoltcp::Error>,
    {
        debug_assert!(self.buffer.is_empty());
        *self.buffer = Vec::with_capacity(len);
        unsafe { self.buffer.set_len(len); }
        f(&mut self.buffer)
    }
}
